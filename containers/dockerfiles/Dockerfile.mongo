# MongoDB Container for Cloudflare Containers
# Includes HTTP bridge for Worker communication
# Designed for linux/amd64 architecture
FROM --platform=linux/amd64 mongo:7

# Install Node.js for HTTP bridge
RUN apt-get update && apt-get install -y \
    nodejs \
    npm \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Environment variables
ENV MONGODB_URI=mongodb://localhost:27017

# Create HTTP bridge directory
WORKDIR /app

# Create package.json
RUN cat > /app/package.json << 'EOF'
{
  "name": "mongo-http-bridge",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "mongodb": "^6.0.0"
  }
}
EOF

RUN npm install

# Create the HTTP bridge server
RUN cat > /app/server.mjs << 'EOF'
import { createServer } from 'http';
import { MongoClient, ObjectId } from 'mongodb';

const uri = process.env.MONGODB_URI || 'mongodb://localhost:27017';
const client = new MongoClient(uri);

let connected = false;

async function connect() {
  if (!connected) {
    await client.connect();
    connected = true;
  }
  return client;
}

// Parse ObjectId strings in filter objects
function parseObjectIds(obj) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (Array.isArray(obj)) return obj.map(parseObjectIds);

  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'string' && /^[0-9a-fA-F]{24}$/.test(value) && key === '_id') {
      result[key] = new ObjectId(value);
    } else if (typeof value === 'object' && value !== null) {
      result[key] = parseObjectIds(value);
    } else {
      result[key] = value;
    }
  }
  return result;
}

const server = createServer(async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }

  try {
    if (url.pathname === '/health' || url.pathname === '/ping') {
      const c = await connect();
      await c.db('admin').command({ ping: 1 });
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'healthy' }));
      return;
    }

    if (url.pathname === '/ready') {
      try {
        const c = await connect();
        await c.db('admin').command({ ping: 1 });
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: true }));
      } catch {
        res.writeHead(503, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: false }));
      }
      return;
    }

    if (req.method !== 'POST') {
      res.writeHead(405, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Method not allowed' }));
      return;
    }

    const body = await new Promise((resolve, reject) => {
      let data = '';
      req.on('data', chunk => data += chunk);
      req.on('end', () => {
        try {
          resolve(JSON.parse(data || '{}'));
        } catch (e) {
          reject(new Error('Invalid JSON body'));
        }
      });
      req.on('error', reject);
    });

    const c = await connect();
    const db = c.db(body.database || 'test');
    const collection = body.collection ? db.collection(body.collection) : null;

    // Generic query endpoint - supports MongoDB operations via JSON
    // Format: { sql: "find|insertOne|updateOne|deleteOne|aggregate", params: {...} }
    // Or use the operation-specific endpoints below
    if (url.pathname === '/query') {
      const operation = body.sql || body.query || body.operation;
      const params = body.params || {};

      if (!operation) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql/query/operation parameter' }));
        return;
      }

      if (!collection && !['listCollections', 'listDatabases', 'createCollection'].includes(operation)) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing collection parameter' }));
        return;
      }

      let result;
      const filter = parseObjectIds(params.filter || {});

      switch (operation) {
        case 'find':
          const cursor = collection.find(filter, {
            projection: params.projection,
            sort: params.sort,
            limit: params.limit,
            skip: params.skip,
          });
          result = { rows: await cursor.toArray(), rowCount: await collection.countDocuments(filter) };
          break;

        case 'findOne':
          const doc = await collection.findOne(filter, { projection: params.projection });
          result = { rows: doc ? [doc] : [], rowCount: doc ? 1 : 0 };
          break;

        case 'insertOne':
          const insertResult = await collection.insertOne(params.document || params.doc);
          result = { rows: [], rowCount: 1, insertedId: insertResult.insertedId?.toString() };
          break;

        case 'insertMany':
          const insertManyResult = await collection.insertMany(params.documents || params.docs);
          result = { rows: [], rowCount: insertManyResult.insertedCount };
          break;

        case 'updateOne':
          const updateResult = await collection.updateOne(filter, params.update, { upsert: params.upsert });
          result = { rows: [], rowCount: updateResult.modifiedCount, matchedCount: updateResult.matchedCount };
          break;

        case 'updateMany':
          const updateManyResult = await collection.updateMany(filter, params.update, { upsert: params.upsert });
          result = { rows: [], rowCount: updateManyResult.modifiedCount, matchedCount: updateManyResult.matchedCount };
          break;

        case 'deleteOne':
          const deleteResult = await collection.deleteOne(filter);
          result = { rows: [], rowCount: deleteResult.deletedCount };
          break;

        case 'deleteMany':
          const deleteManyResult = await collection.deleteMany(filter);
          result = { rows: [], rowCount: deleteManyResult.deletedCount };
          break;

        case 'aggregate':
          const aggCursor = collection.aggregate(params.pipeline || []);
          const aggDocs = await aggCursor.toArray();
          result = { rows: aggDocs, rowCount: aggDocs.length };
          break;

        case 'count':
          const count = await collection.countDocuments(filter);
          result = { rows: [{ count }], rowCount: 1 };
          break;

        case 'listCollections':
          const collections = await db.listCollections().toArray();
          result = { rows: collections.map(c => ({ name: c.name })), rowCount: collections.length };
          break;

        case 'createCollection':
          await db.createCollection(params.name);
          result = { rows: [], rowCount: 0, created: true };
          break;

        case 'createIndex':
          const indexName = await collection.createIndex(params.keys, { unique: params.unique, name: params.name });
          result = { rows: [{ indexName }], rowCount: 1 };
          break;

        default:
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: `Unknown operation: ${operation}` }));
          return;
      }

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(result));
      return;
    }

    // MongoDB-specific endpoints for backwards compatibility
    if (url.pathname === '/find') {
      const cursor = collection.find(parseObjectIds(body.filter || {}), {
        projection: body.projection,
        sort: body.sort,
        limit: body.limit,
        skip: body.skip,
      });
      const documents = await cursor.toArray();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ documents, rows: documents, rowCount: documents.length }));
      return;
    }

    if (url.pathname === '/findOne') {
      const document = await collection.findOne(parseObjectIds(body.filter || {}), {
        projection: body.projection,
      });
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ document, rows: document ? [document] : [], rowCount: document ? 1 : 0 }));
      return;
    }

    if (url.pathname === '/insertOne') {
      const result = await collection.insertOne(body.document);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        acknowledged: result.acknowledged,
        insertedId: result.insertedId?.toString(),
        insertedCount: 1,
        rowCount: 1,
      }));
      return;
    }

    if (url.pathname === '/insertMany') {
      const result = await collection.insertMany(body.documents);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        acknowledged: result.acknowledged,
        insertedCount: result.insertedCount,
        rowCount: result.insertedCount,
      }));
      return;
    }

    if (url.pathname === '/updateOne') {
      const result = await collection.updateOne(
        parseObjectIds(body.filter || {}),
        body.update,
        { upsert: body.upsert }
      );
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        acknowledged: result.acknowledged,
        matchedCount: result.matchedCount,
        modifiedCount: result.modifiedCount,
        upsertedCount: result.upsertedCount,
        upsertedId: result.upsertedId?.toString(),
        rowCount: result.modifiedCount,
      }));
      return;
    }

    if (url.pathname === '/updateMany') {
      const result = await collection.updateMany(
        parseObjectIds(body.filter || {}),
        body.update,
        { upsert: body.upsert }
      );
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        acknowledged: result.acknowledged,
        matchedCount: result.matchedCount,
        modifiedCount: result.modifiedCount,
        upsertedCount: result.upsertedCount,
        rowCount: result.modifiedCount,
      }));
      return;
    }

    if (url.pathname === '/deleteOne') {
      const result = await collection.deleteOne(parseObjectIds(body.filter || {}));
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        acknowledged: result.acknowledged,
        deletedCount: result.deletedCount,
        rowCount: result.deletedCount,
      }));
      return;
    }

    if (url.pathname === '/deleteMany') {
      const result = await collection.deleteMany(parseObjectIds(body.filter || {}));
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        acknowledged: result.acknowledged,
        deletedCount: result.deletedCount,
        rowCount: result.deletedCount,
      }));
      return;
    }

    if (url.pathname === '/aggregate') {
      const cursor = collection.aggregate(body.pipeline || []);
      const documents = await cursor.toArray();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ documents, rows: documents, rowCount: documents.length }));
      return;
    }

    if (url.pathname === '/count') {
      const count = await collection.countDocuments(parseObjectIds(body.filter || {}));
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ count, rows: [{ count }], rowCount: 1 }));
      return;
    }

    if (url.pathname === '/createIndex') {
      const indexName = await collection.createIndex(body.keys, {
        unique: body.unique,
        name: body.name,
      });
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ indexName }));
      return;
    }

    if (url.pathname === '/listCollections') {
      const collections = await db.listCollections().toArray();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        collections: collections.map(c => c.name),
        rows: collections.map(c => ({ name: c.name })),
        rowCount: collections.length,
      }));
      return;
    }

    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Not found' }));

  } catch (error) {
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: error.message }));
  }
});

server.listen(8080, '0.0.0.0', () => {
  console.log('MongoDB HTTP bridge listening on port 8080');
});
EOF

# Create entrypoint script
RUN cat > /app/entrypoint.sh << 'EOF'
#!/bin/bash
set -e

# Start MongoDB in background
mongod --bind_ip_all --fork --logpath /var/log/mongodb.log

# Wait for MongoDB to be ready
until mongosh --eval "db.adminCommand('ping')" > /dev/null 2>&1; do
  echo "Waiting for MongoDB..."
  sleep 1
done

echo "MongoDB is ready"

# Start HTTP bridge
exec node /app/server.mjs
EOF

RUN chmod +x /app/entrypoint.sh

# Expose HTTP bridge port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=5s --timeout=3s --start-period=15s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

ENTRYPOINT ["/app/entrypoint.sh"]
