# ClickHouse Container for Cloudflare Containers
# Uses native HTTP interface with a Node.js bridge for consistent API
# Designed for linux/amd64 architecture
FROM --platform=linux/amd64 clickhouse/clickhouse-server:latest

# Install Node.js for HTTP bridge
RUN apt-get update && apt-get install -y \
    nodejs \
    npm \
    curl \
    && rm -rf /var/lib/apt/lists/*

# ClickHouse configuration
ENV CLICKHOUSE_USER=default
ENV CLICKHOUSE_DEFAULT_ACCESS_MANAGEMENT=1

# Create config to enable HTTP interface
RUN cat > /etc/clickhouse-server/config.d/http.xml << 'EOF'
<clickhouse>
    <http_port>8123</http_port>
    <listen_host>0.0.0.0</listen_host>
    <max_connections>100</max_connections>
    <max_concurrent_queries>100</max_concurrent_queries>
    <uncompressed_cache_size>8589934592</uncompressed_cache_size>
    <mark_cache_size>5368709120</mark_cache_size>
    <path>/var/lib/clickhouse/</path>
    <tmp_path>/var/lib/clickhouse/tmp/</tmp_path>
    <user_files_path>/var/lib/clickhouse/user_files/</user_files_path>
    <format_schema_path>/var/lib/clickhouse/format_schemas/</format_schema_path>
</clickhouse>
EOF

# Create user config
RUN cat > /etc/clickhouse-server/users.d/default.xml << 'EOF'
<clickhouse>
    <users>
        <default>
            <password></password>
            <networks>
                <ip>::/0</ip>
            </networks>
            <profile>default</profile>
            <quota>default</quota>
            <access_management>1</access_management>
        </default>
    </users>
</clickhouse>
EOF

# Create HTTP bridge directory
WORKDIR /app

# Create package.json for the bridge
RUN cat > /app/package.json << 'EOF'
{
  "name": "clickhouse-http-bridge",
  "version": "1.0.0",
  "type": "module"
}
EOF

# Create the HTTP bridge server for consistent API
RUN cat > /app/server.mjs << 'EOF'
import { createServer } from 'http';
import { request as httpRequest } from 'http';

const CLICKHOUSE_HOST = 'localhost';
const CLICKHOUSE_PORT = 8123;

// Forward query to ClickHouse native HTTP interface
async function queryClickHouse(sql, format = 'JSON') {
  return new Promise((resolve, reject) => {
    const postData = sql;
    const options = {
      hostname: CLICKHOUSE_HOST,
      port: CLICKHOUSE_PORT,
      path: `/?default_format=${format}`,
      method: 'POST',
      headers: {
        'Content-Type': 'text/plain',
        'Content-Length': Buffer.byteLength(postData),
      },
    };

    const req = httpRequest(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        if (res.statusCode >= 400) {
          reject(new Error(data || `ClickHouse error: ${res.statusCode}`));
        } else {
          try {
            resolve(JSON.parse(data));
          } catch {
            resolve({ raw: data });
          }
        }
      });
    });

    req.on('error', reject);
    req.write(postData);
    req.end();
  });
}

// Health check using ClickHouse ping
async function pingClickHouse() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: CLICKHOUSE_HOST,
      port: CLICKHOUSE_PORT,
      path: '/ping',
      method: 'GET',
    };

    const req = httpRequest(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        if (res.statusCode === 200) {
          resolve(true);
        } else {
          reject(new Error('ClickHouse not healthy'));
        }
      });
    });

    req.on('error', reject);
    req.end();
  });
}

const server = createServer(async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }

  try {
    if (url.pathname === '/health' || url.pathname === '/ping') {
      await pingClickHouse();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'healthy' }));
      return;
    }

    if (url.pathname === '/ready') {
      try {
        await pingClickHouse();
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: true }));
      } catch {
        res.writeHead(503, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: false }));
      }
      return;
    }

    if (req.method !== 'POST') {
      res.writeHead(405, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Method not allowed' }));
      return;
    }

    const body = await new Promise((resolve) => {
      let data = '';
      req.on('data', chunk => data += chunk);
      req.on('end', () => resolve(JSON.parse(data || '{}')));
    });

    if (url.pathname === '/query') {
      // Support both 'sql' and 'query' for backwards compatibility
      const sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }

      const result = await queryClickHouse(sql, 'JSON');

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        rows: result.data || [],
        rowCount: result.rows || (result.data ? result.data.length : 0),
        meta: result.meta || [],
        statistics: result.statistics || {},
      }));
      return;
    }

    if (url.pathname === '/execute') {
      // Support both 'sql' and 'query' for backwards compatibility
      const sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }

      await queryClickHouse(sql, 'JSON');
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ success: true }));
      return;
    }

    // Proxy raw queries to ClickHouse native interface
    if (url.pathname === '/raw') {
      const sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }

      const result = await queryClickHouse(sql, body.format || 'JSON');
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(result));
      return;
    }

    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Not found' }));

  } catch (error) {
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: error.message }));
  }
});

server.listen(8080, '0.0.0.0', () => {
  console.log('ClickHouse HTTP bridge listening on port 8080');
});
EOF

# Create entrypoint script
RUN cat > /app/entrypoint.sh << 'EOF'
#!/bin/bash
set -e

# Start ClickHouse in background
/entrypoint.sh &

# Wait for ClickHouse to be ready
until curl -s http://localhost:8123/ping > /dev/null 2>&1; do
  echo "Waiting for ClickHouse..."
  sleep 1
done

echo "ClickHouse is ready"

# Start HTTP bridge
exec node /app/server.mjs
EOF

RUN chmod +x /app/entrypoint.sh

# Expose HTTP bridge port (primary) and native ClickHouse port (for direct access)
EXPOSE 8080
EXPOSE 8123

# Health check using the bridge
HEALTHCHECK --interval=5s --timeout=3s --start-period=15s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

ENTRYPOINT ["/app/entrypoint.sh"]
