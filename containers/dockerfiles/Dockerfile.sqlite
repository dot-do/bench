# SQLite Container for Cloudflare Containers
# Uses Bun with built-in SQLite (bun:sqlite) - no native module compilation!
# Designed for linux/amd64 architecture
#
# Benefits of Bun:
# - Built-in SQLite, no native module compilation needed
# - Much faster startup than Node.js
# - Smaller image size
# - Expected cold start: <5 seconds (vs 53s with Node.js + better-sqlite3)

FROM --platform=linux/amd64 oven/bun:1-alpine

# Install only curl for health checks
RUN apk add --no-cache curl

# Create app directory
WORKDIR /app

# Create the HTTP bridge server using Bun's built-in SQLite
RUN cat > /app/server.ts << 'EOF'
import { Database } from "bun:sqlite";

// Database cache for multiple named databases
const databases = new Map<string, Database>();

function getDatabase(dbPath?: string): Database {
  const key = dbPath || ":memory:";
  if (!databases.has(key)) {
    const db = new Database(key === ":memory:" ? ":memory:" : `/data/${key}`);
    db.exec("PRAGMA journal_mode = WAL");
    db.exec("PRAGMA busy_timeout = 5000");
    db.exec("PRAGMA foreign_keys = ON");
    db.exec("PRAGMA synchronous = NORMAL");
    databases.set(key, db);
  }
  return databases.get(key)!;
}

/**
 * Convert PostgreSQL-style $1, $2 placeholders to SQLite ?1, ?2 placeholders.
 * Bun's SQLite supports ?N for positional parameters.
 */
function convertPlaceholders(sql: string, params: unknown[]): { sql: string; params: unknown[] } {
  if (!params || params.length === 0) {
    return { sql, params: params || [] };
  }

  // Convert $N to ?N (Bun SQLite supports ?N syntax)
  const converted = sql.replace(/\$(\d+)/g, "?$1");
  return { sql: converted, params };
}

const server = Bun.serve({
  port: 8080,
  hostname: "0.0.0.0",

  async fetch(req: Request): Promise<Response> {
    const url = new URL(req.url);

    // CORS headers
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    };

    if (req.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders });
    }

    try {
      // Health check - return immediately WITHOUT initializing DB
      // Per Cloudflare recommendation: "No database connections, no model loading"
      if (url.pathname === "/health" || url.pathname === "/ping") {
        return Response.json({ status: "healthy" }, { headers: corsHeaders });
      }

      // Ready check - verify SQLite works
      if (url.pathname === "/ready") {
        try {
          const db = getDatabase(":memory:");
          db.query("SELECT 1").get();
          return Response.json({ ready: true }, { headers: corsHeaders });
        } catch {
          return Response.json({ ready: false }, { status: 503, headers: corsHeaders });
        }
      }

      if (req.method !== "POST") {
        return Response.json({ error: "Method not allowed" }, { status: 405, headers: corsHeaders });
      }

      const body = await req.json().catch(() => ({}));
      const db = getDatabase(body.database || ":memory:");

      if (url.pathname === "/query") {
        let sql = body.sql || body.query;
        if (!sql) {
          return Response.json({ error: "Missing sql or query parameter" }, { status: 400, headers: corsHeaders });
        }

        const converted = convertPlaceholders(sql, body.params || []);
        sql = converted.sql;
        const params = converted.params;

        const isSelect = /^\s*(SELECT|PRAGMA|EXPLAIN)/i.test(sql);

        if (isSelect) {
          const stmt = db.query(sql);
          const rows = params.length > 0 ? stmt.all(...params) : stmt.all();
          return Response.json({
            rows,
            rowCount: rows.length,
            rowsAffected: 0,
            lastInsertRowid: null,
            changes: 0,
          }, { headers: corsHeaders });
        } else {
          const stmt = db.query(sql);
          params.length > 0 ? stmt.run(...params) : stmt.run();
          return Response.json({
            rows: [],
            rowCount: 0,
            rowsAffected: db.changes,
            lastInsertRowid: db.lastInsertRowId,
            changes: db.changes,
          }, { headers: corsHeaders });
        }
      }

      if (url.pathname === "/execute") {
        let sql = body.sql || body.query;
        if (!sql) {
          return Response.json({ error: "Missing sql or query parameter" }, { status: 400, headers: corsHeaders });
        }

        const converted = convertPlaceholders(sql, body.params || []);
        sql = converted.sql;
        const params = converted.params;

        const stmt = db.query(sql);
        params.length > 0 ? stmt.run(...params) : stmt.run();

        return Response.json({
          success: true,
          rowsAffected: db.changes,
          lastInsertRowid: db.lastInsertRowId,
        }, { headers: corsHeaders });
      }

      if (url.pathname === "/batch") {
        const statements = body.statements || [];
        const results: unknown[] = [];

        db.exec("BEGIN TRANSACTION");
        try {
          for (const s of statements) {
            let sql = s.sql || s.query;
            if (!sql) continue;

            const converted = convertPlaceholders(sql, s.params || []);
            sql = converted.sql;
            const params = converted.params;

            const isSelect = /^\s*(SELECT|PRAGMA|EXPLAIN)/i.test(sql);
            const stmt = db.query(sql);

            if (isSelect) {
              const rows = params.length > 0 ? stmt.all(...params) : stmt.all();
              results.push({
                rows,
                rowCount: rows.length,
                rowsAffected: 0,
                lastInsertRowid: null,
                changes: 0,
              });
            } else {
              params.length > 0 ? stmt.run(...params) : stmt.run();
              results.push({
                rows: [],
                rowCount: 0,
                rowsAffected: db.changes,
                lastInsertRowid: db.lastInsertRowId,
                changes: db.changes,
              });
            }
          }
          db.exec("COMMIT");
        } catch (e) {
          db.exec("ROLLBACK");
          throw e;
        }

        return Response.json(results, { headers: corsHeaders });
      }

      if (url.pathname === "/tables") {
        const tables = db.query(
          "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'"
        ).all();
        return Response.json({
          rows: tables,
          rowCount: tables.length,
        }, { headers: corsHeaders });
      }

      return Response.json({ error: "Not found" }, { status: 404, headers: corsHeaders });

    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      return Response.json({ error: message }, { status: 500, headers: corsHeaders });
    }
  },
});

console.log(`SQLite HTTP bridge (Bun) listening on port ${server.port}`);
EOF

# Create data directory for persistent databases
RUN mkdir -p /data

# Environment variables
ENV SQLITE_DB=:memory:

# Expose HTTP bridge port
EXPOSE 8080

# Health check - lightweight, no DB initialization
HEALTHCHECK --interval=5s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

CMD ["bun", "run", "/app/server.ts"]
