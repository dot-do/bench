# SQLite Container for Cloudflare Containers
# Alpine-based with SQLite3 and HTTP bridge
# Designed for linux/amd64 architecture
FROM --platform=linux/amd64 alpine:3.19

# Install dependencies (including build tools for better-sqlite3 native module)
RUN apk add --no-cache \
    nodejs \
    npm \
    sqlite \
    curl \
    python3 \
    make \
    g++

# Create HTTP bridge directory
WORKDIR /app

# Create package.json
RUN cat > /app/package.json << 'EOF'
{
  "name": "sqlite-http-bridge",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "better-sqlite3": "^11.0.0"
  }
}
EOF

RUN npm install

# Create the HTTP bridge server
RUN cat > /app/server.mjs << 'EOF'
import { createServer } from 'http';
import Database from 'better-sqlite3';

// Database cache for multiple named databases
const databases = new Map();

function getDatabase(dbPath) {
  const key = dbPath || ':memory:';
  if (!databases.has(key)) {
    const db = new Database(key === ':memory:' ? ':memory:' : `/data/${key}`);
    db.pragma('journal_mode = WAL');
    db.pragma('busy_timeout = 5000');
    db.pragma('foreign_keys = ON');
    db.pragma('synchronous = NORMAL');
    databases.set(key, db);
  }
  return databases.get(key);
}

/**
 * Convert PostgreSQL-style $1, $2 placeholders to SQLite ? placeholders.
 * This allows the bridge to accept queries written for PostgreSQL.
 * better-sqlite3 expects ? for positional parameters when passed as an array.
 * @param {string} sql - SQL with $1, $2, etc. placeholders
 * @param {Array} params - Parameter values array
 * @returns {{sql: string, params: Array}} - SQL with ? placeholders and reordered params
 */
function convertPlaceholders(sql, params) {
  if (!params || params.length === 0) {
    return { sql, params: params || [] };
  }

  // Find all $N placeholders
  const regex = /\$(\d+)/g;
  const matches = [];
  let match;
  while ((match = regex.exec(sql)) !== null) {
    matches.push({ index: parseInt(match[1], 10), pos: match.index, len: match[0].length });
  }

  // If no placeholders found, return original SQL
  if (matches.length === 0) {
    return { sql, params };
  }

  // Build the new SQL with ? placeholders and reorder params
  // Sort matches by position for replacement
  matches.sort((a, b) => a.pos - b.pos);

  let result = '';
  let lastPos = 0;
  const newParams = [];

  for (const m of matches) {
    result += sql.slice(lastPos, m.pos) + '?';
    lastPos = m.pos + m.len;
    // $1 corresponds to params[0], $2 to params[1], etc.
    const paramIndex = m.index - 1;
    if (paramIndex >= 0 && paramIndex < params.length) {
      newParams.push(params[paramIndex]);
    } else {
      newParams.push(null); // Fallback for out-of-bounds
    }
  }
  result += sql.slice(lastPos);

  return { sql: result, params: newParams };
}

const server = createServer(async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }

  try {
    if (url.pathname === '/health' || url.pathname === '/ping') {
      const db = getDatabase(':memory:');
      db.prepare('SELECT 1').get();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'healthy' }));
      return;
    }

    if (url.pathname === '/ready') {
      try {
        const db = getDatabase(':memory:');
        db.prepare('SELECT 1').get();
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: true }));
      } catch {
        res.writeHead(503, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: false }));
      }
      return;
    }

    if (req.method !== 'POST') {
      res.writeHead(405, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Method not allowed' }));
      return;
    }

    const body = await new Promise((resolve, reject) => {
      let data = '';
      req.on('data', chunk => data += chunk);
      req.on('end', () => {
        try {
          resolve(JSON.parse(data || '{}'));
        } catch (e) {
          reject(new Error('Invalid JSON body'));
        }
      });
      req.on('error', reject);
    });

    const db = getDatabase(body.database || ':memory:');

    if (url.pathname === '/query') {
      // Support both 'sql' and 'query' for backwards compatibility
      let sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }

      // Convert $1, $2 placeholders to ? for better-sqlite3 compatibility
      const converted = convertPlaceholders(sql, body.params || []);
      sql = converted.sql;
      const params = converted.params;

      const stmt = db.prepare(sql);
      const isSelect = sql.trim().toUpperCase().startsWith('SELECT') ||
                       sql.trim().toUpperCase().startsWith('PRAGMA') ||
                       sql.trim().toUpperCase().startsWith('EXPLAIN');

      if (isSelect) {
        const rows = stmt.all(...params);
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          rows,
          rowCount: rows.length,
          rowsAffected: 0,
          lastInsertRowid: null,
          changes: 0,
        }));
      } else {
        const result = stmt.run(...params);
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          rows: [],
          rowCount: 0,
          rowsAffected: result.changes,
          lastInsertRowid: result.lastInsertRowid,
          changes: result.changes,
        }));
      }
      return;
    }

    if (url.pathname === '/execute') {
      // Support both 'sql' and 'query' for backwards compatibility
      let sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }

      // Convert $1, $2 placeholders to ? for better-sqlite3 compatibility
      const converted = convertPlaceholders(sql, body.params || []);
      sql = converted.sql;
      const params = converted.params;

      const stmt = db.prepare(sql);
      const result = stmt.run(...params);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        success: true,
        rowsAffected: result.changes,
        lastInsertRowid: result.lastInsertRowid,
      }));
      return;
    }

    if (url.pathname === '/batch') {
      const statements = body.statements || [];
      const results = [];

      const transaction = db.transaction((stmts) => {
        for (const s of stmts) {
          let sql = s.sql || s.query;
          if (!sql) continue;

          // Convert $1, $2 placeholders to ? for better-sqlite3 compatibility
          const converted = convertPlaceholders(sql, s.params || []);
          sql = converted.sql;
          const params = converted.params;

          const prepared = db.prepare(sql);
          const isSelect = sql.trim().toUpperCase().startsWith('SELECT') ||
                           sql.trim().toUpperCase().startsWith('PRAGMA') ||
                           sql.trim().toUpperCase().startsWith('EXPLAIN');

          if (isSelect) {
            const rows = prepared.all(...params);
            results.push({
              rows,
              rowCount: rows.length,
              rowsAffected: 0,
              lastInsertRowid: null,
              changes: 0,
            });
          } else {
            const result = prepared.run(...params);
            results.push({
              rows: [],
              rowCount: 0,
              rowsAffected: result.changes,
              lastInsertRowid: result.lastInsertRowid,
              changes: result.changes,
            });
          }
        }
      });

      transaction(statements);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(results));
      return;
    }

    if (url.pathname === '/backup') {
      const dest = body.destination || body.dest;
      if (!dest) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing destination parameter' }));
        return;
      }
      await db.backup(`/data/${dest}`);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ success: true }));
      return;
    }

    if (url.pathname === '/tables') {
      const tables = db.prepare(
        "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'"
      ).all();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        rows: tables,
        rowCount: tables.length,
      }));
      return;
    }

    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Not found' }));

  } catch (error) {
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: error.message }));
  }
});

server.listen(8080, '0.0.0.0', () => {
  console.log('SQLite HTTP bridge listening on port 8080');
});
EOF

# Create data directory for persistent databases
RUN mkdir -p /data

# Environment variables
ENV SQLITE_DB=:memory:

# Expose HTTP bridge port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=5s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

CMD ["node", "/app/server.mjs"]
