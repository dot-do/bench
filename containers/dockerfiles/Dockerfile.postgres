# PostgreSQL Container for Cloudflare Containers
# Includes HTTP bridge for Worker communication
# Designed for linux/amd64 architecture
FROM --platform=linux/amd64 postgres:16-alpine

# Install dependencies for HTTP bridge
RUN apk add --no-cache \
    nodejs \
    npm \
    curl

# Set up PostgreSQL
ENV POSTGRES_USER=postgres
ENV POSTGRES_PASSWORD=postgres
ENV POSTGRES_DB=postgres
ENV PGDATA=/var/lib/postgresql/data

# Create HTTP bridge directory
WORKDIR /app

# Create simple HTTP-to-PostgreSQL bridge
RUN cat > /app/package.json << 'EOF'
{
  "name": "pg-http-bridge",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "pg": "^8.11.0"
  }
}
EOF

RUN npm install

# Create the HTTP bridge server
RUN cat > /app/server.mjs << 'EOF'
import { createServer } from 'http';
import pg from 'pg';

const { Pool } = pg;

const pool = new Pool({
  host: 'localhost',
  port: 5432,
  user: process.env.POSTGRES_USER || 'postgres',
  password: process.env.POSTGRES_PASSWORD || 'postgres',
  database: process.env.POSTGRES_DB || 'postgres',
});

const server = createServer(async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }

  try {
    if (url.pathname === '/health' || url.pathname === '/ping') {
      await pool.query('SELECT 1');
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'healthy' }));
      return;
    }

    if (url.pathname === '/ready') {
      try {
        await pool.query('SELECT 1');
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: true }));
      } catch {
        res.writeHead(503, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: false }));
      }
      return;
    }

    if (req.method !== 'POST') {
      res.writeHead(405, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Method not allowed' }));
      return;
    }

    const body = await new Promise((resolve) => {
      let data = '';
      req.on('data', chunk => data += chunk);
      req.on('end', () => resolve(JSON.parse(data || '{}')));
    });

    if (url.pathname === '/query') {
      // Support both 'sql' and 'query' for backwards compatibility
      const sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }
      const result = await pool.query(sql, body.params || []);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        rows: result.rows,
        rowCount: result.rowCount,
        fields: result.fields?.map(f => ({
          name: f.name,
          dataTypeID: f.dataTypeID,
        })) || [],
      }));
      return;
    }

    if (url.pathname === '/execute') {
      // Support both 'sql' and 'query' for backwards compatibility
      const sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }
      const result = await pool.query(sql, body.params || []);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ rowsAffected: result.rowCount || 0 }));
      return;
    }

    if (url.pathname === '/transaction/begin') {
      await pool.query('BEGIN');
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ started: true }));
      return;
    }

    if (url.pathname === '/transaction/commit') {
      await pool.query('COMMIT');
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ committed: true }));
      return;
    }

    if (url.pathname === '/transaction/rollback') {
      await pool.query('ROLLBACK');
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ rolledBack: true }));
      return;
    }

    if (url.pathname === '/admin/databases') {
      const result = await pool.query("SELECT datname FROM pg_database WHERE datistemplate = false");
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ databases: result.rows.map(r => r.datname) }));
      return;
    }

    if (url.pathname === '/admin/create-database') {
      await pool.query(`CREATE DATABASE ${body.name}`);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ created: true }));
      return;
    }

    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Not found' }));

  } catch (error) {
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: error.message }));
  }
});

server.listen(8080, '0.0.0.0', () => {
  console.log('PostgreSQL HTTP bridge listening on port 8080');
});
EOF

# Create entrypoint script
RUN cat > /app/entrypoint.sh << 'EOF'
#!/bin/sh
set -e

# Start PostgreSQL in background
docker-entrypoint.sh postgres &

# Wait for PostgreSQL to be ready
until pg_isready -U postgres; do
  echo "Waiting for PostgreSQL..."
  sleep 1
done

echo "PostgreSQL is ready"

# Start HTTP bridge
exec node /app/server.mjs
EOF

RUN chmod +x /app/entrypoint.sh

# Expose HTTP bridge port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=5s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

ENTRYPOINT ["/app/entrypoint.sh"]
