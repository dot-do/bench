# DuckDB Container for Cloudflare Containers
# Custom container with DuckDB CLI and HTTP bridge
# Designed for linux/amd64 architecture
FROM --platform=linux/amd64 alpine:3.19

# Install dependencies
RUN apk add --no-cache \
    nodejs \
    npm \
    curl \
    wget \
    unzip

# Install DuckDB CLI
RUN wget https://github.com/duckdb/duckdb/releases/download/v1.0.0/duckdb_cli-linux-amd64.zip \
    && unzip duckdb_cli-linux-amd64.zip \
    && mv duckdb /usr/local/bin/ \
    && chmod +x /usr/local/bin/duckdb \
    && rm duckdb_cli-linux-amd64.zip

# Create HTTP bridge directory
WORKDIR /app

# Create package.json
RUN cat > /app/package.json << 'EOF'
{
  "name": "duckdb-http-bridge",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "duckdb": "^1.0.0"
  }
}
EOF

RUN npm install

# Create the HTTP bridge server
RUN cat > /app/server.mjs << 'EOF'
import { createServer } from 'http';
import duckdb from 'duckdb';

// Database instance - can be memory or file-based
const DB_PATH = process.env.DUCKDB_PATH || ':memory:';
const db = new duckdb.Database(DB_PATH);
const conn = db.connect();

// Promisify DuckDB methods
function query(sql, params = []) {
  return new Promise((resolve, reject) => {
    if (params && params.length > 0) {
      const stmt = conn.prepare(sql);
      stmt.all(...params, (err, rows) => {
        stmt.finalize();
        if (err) reject(err);
        else resolve(rows);
      });
    } else {
      conn.all(sql, (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    }
  });
}

function run(sql, params = []) {
  return new Promise((resolve, reject) => {
    if (params && params.length > 0) {
      const stmt = conn.prepare(sql);
      stmt.run(...params, (err) => {
        stmt.finalize();
        if (err) reject(err);
        else resolve();
      });
    } else {
      conn.run(sql, (err) => {
        if (err) reject(err);
        else resolve();
      });
    }
  });
}

const server = createServer(async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }

  try {
    if (url.pathname === '/health' || url.pathname === '/ping') {
      await query('SELECT 1');
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'healthy' }));
      return;
    }

    if (url.pathname === '/ready') {
      try {
        await query('SELECT 1');
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: true }));
      } catch {
        res.writeHead(503, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: false }));
      }
      return;
    }

    if (req.method !== 'POST') {
      res.writeHead(405, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Method not allowed' }));
      return;
    }

    const body = await new Promise((resolve, reject) => {
      let data = '';
      req.on('data', chunk => data += chunk);
      req.on('end', () => {
        try {
          resolve(JSON.parse(data || '{}'));
        } catch (e) {
          reject(new Error('Invalid JSON body'));
        }
      });
      req.on('error', reject);
    });

    if (url.pathname === '/query') {
      // Support both 'sql' and 'query' for backwards compatibility
      const sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }

      const startTime = performance.now();
      const rows = await query(sql, body.params || []);
      const time = (performance.now() - startTime) / 1000;

      // Get column info if available
      const columns = rows.length > 0
        ? Object.keys(rows[0]).map(name => ({ name, type: typeof rows[0][name] }))
        : [];

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        rows,
        rowCount: rows.length,
        columns,
        time,
      }));
      return;
    }

    if (url.pathname === '/execute') {
      // Support both 'sql' and 'query' for backwards compatibility
      const sql = body.sql || body.query;
      if (!sql) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing sql or query parameter' }));
        return;
      }

      await run(sql, body.params || []);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ success: true, rowsAffected: 0 }));
      return;
    }

    if (url.pathname === '/batch') {
      const statements = body.statements || [];
      const results = [];

      for (const stmt of statements) {
        const sql = stmt.sql || stmt.query;
        if (!sql) continue;

        const startTime = performance.now();
        const rows = await query(sql, stmt.params || []);
        const time = (performance.now() - startTime) / 1000;

        results.push({
          rows,
          rowCount: rows.length,
          time,
        });
      }

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(results));
      return;
    }

    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Not found' }));

  } catch (error) {
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: error.message }));
  }
});

server.listen(8080, '0.0.0.0', () => {
  console.log('DuckDB HTTP bridge listening on port 8080');
});
EOF

# Create data directory for persistent databases
RUN mkdir -p /data

# Environment variables
ENV DUCKDB_PATH=:memory:

# Expose HTTP bridge port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=5s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

CMD ["node", "/app/server.mjs"]
