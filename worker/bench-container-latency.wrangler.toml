# Wrangler configuration for Container vs WASM Latency Benchmark Worker
#
# This worker compares latency characteristics between:
# - WASM databases running in-Worker
# - Containerized databases running in Cloudflare Containers
#
# Deploy: wrangler deploy -c worker/bench-container-latency.wrangler.toml

name = "bench-container-latency"
account_id = "b6641681fe423910342b9ffa1364c76d"
main = "bench-container-latency.ts"
compatibility_date = "2025-01-21"
compatibility_flags = ["nodejs_compat"]

# Enable logpush for benchmark analysis
logpush = true

# Worker limits
[limits]
cpu_ms = 30000  # 30 seconds for batch benchmarks

# Development settings
[dev]
port = 8787
local_protocol = "http"

# R2 bucket for storing benchmark results
[[r2_buckets]]
binding = "BENCHMARK_RESULTS"
bucket_name = "bench-results"
preview_bucket_name = "bench-results-preview"

# ==============================================================================
# Durable Object Bindings
# ==============================================================================
# Durable Objects manage container lifecycle and provide simulated mode
# when real Cloudflare Containers are not available.
# ==============================================================================

[[durable_objects.bindings]]
name = "POSTGRES_DO"
class_name = "PostgresContainerDO"

[[durable_objects.bindings]]
name = "CLICKHOUSE_DO"
class_name = "ClickHouseContainerDO"

[[durable_objects.bindings]]
name = "MONGO_DO"
class_name = "MongoContainerDO"

[[durable_objects.bindings]]
name = "DUCKDB_DO"
class_name = "DuckDBContainerDO"

[[durable_objects.bindings]]
name = "SQLITE_DO"
class_name = "SQLiteContainerDO"

# Durable Object migrations
[[migrations]]
tag = "v1"
new_classes = ["PostgresContainerDO", "ClickHouseContainerDO", "MongoContainerDO", "DuckDBContainerDO", "SQLiteContainerDO"]

# ==============================================================================
# Container Bindings
# ==============================================================================
# Each container runs a database with an HTTP bridge for communication.
# Containers support different size tiers affecting performance and cost.
#
# Size tiers:
# - lite:           256MB RAM, 0.25 vCPU ($0.015/hr)
# - basic:          512MB RAM, 0.5 vCPU ($0.03/hr)
# - standard-1:     1GB RAM, 1 vCPU ($0.06/hr)
# - standard-2:     2GB RAM, 2 vCPU ($0.12/hr)
# - standard-4:     4GB RAM, 4 vCPU ($0.24/hr)
# - performance-8:  8GB RAM, 8 vCPU ($0.48/hr)
# - performance-16: 16GB RAM, 16 vCPU ($0.96/hr)
#
# NOTE: Container bindings below are placeholders. When Cloudflare Containers
# become available, uncomment these sections. Until then, use the Durable Object
# based simulated mode for benchmarking.
# ==============================================================================

# PostgreSQL Container
# Runs PostgreSQL with an HTTP REST API bridge
[[containers]]
class_name = "PostgresContainerDO"
image = "../containers/dockerfiles/Dockerfile.postgres"
max_instances = 10

# ClickHouse Container
# ClickHouse has native HTTP interface on port 8123
[[containers]]
class_name = "ClickHouseContainerDO"
image = "../containers/dockerfiles/Dockerfile.clickhouse"
max_instances = 10

# MongoDB Container
# Runs MongoDB with an HTTP REST API bridge
[[containers]]
class_name = "MongoContainerDO"
image = "../containers/dockerfiles/Dockerfile.mongo"
max_instances = 10

# DuckDB Container
# DuckDB with HTTP REST API for analytical queries
[[containers]]
class_name = "DuckDBContainerDO"
image = "../containers/dockerfiles/Dockerfile.duckdb"
max_instances = 10

# SQLite Container
# SQLite with HTTP REST API bridge
[[containers]]
class_name = "SQLiteContainerDO"
image = "../containers/dockerfiles/Dockerfile.sqlite"
max_instances = 10

# ==============================================================================
# Environment-specific configurations
# ==============================================================================

# Production environment
[env.production]
name = "bench-container-latency"
route = { pattern = "bench.dotdo.workers.dev/benchmark/container-latency*", zone_name = "dotdo.workers.dev" }

[[env.production.r2_buckets]]
binding = "BENCHMARK_RESULTS"
bucket_name = "bench-results-prod"

# Staging environment
[env.staging]
name = "bench-container-latency-staging"

[[env.staging.r2_buckets]]
binding = "BENCHMARK_RESULTS"
bucket_name = "bench-results-staging"

# ==============================================================================
# Observability
# ==============================================================================

[observability]
enabled = true

[observability.logs]
enabled = true
invocation_logs = true

# ==============================================================================
# Build configuration
# ==============================================================================

[build]
command = ""

[build.upload]
format = "modules"
main = "./bench-container-latency.ts"

[[build.upload.rules]]
type = "ESModule"
globs = ["**/*.ts"]

# ==============================================================================
# Placement (optional - for specific region targeting)
# ==============================================================================

# Uncomment to pin to specific region for consistent benchmarking
# [placement]
# mode = "smart"
# hint = "iad"  # Ashburn, Virginia (US East)

# ==============================================================================
# Tail workers for real-time monitoring (optional)
# ==============================================================================

# [tail_consumers]
# - service = "bench-analytics"
